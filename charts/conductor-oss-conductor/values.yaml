global:
  # -- Global container image registry override
  imageRegistry: ""
  # -- Global pod image pull secrets
  imagePullSecrets: [ ]

# -- String to partially override the fullname template with a string (will prepend the release name)
nameOverride: ""
# -- String to fully override the fullname template with a string
fullnameOverride: ""

# -- Additional labels to add to all resources
labels: { }
# -- Additional labels to add to pods
podLabels: { }

# -- Annotations to add to all resources
annotations: { }
# -- Additional annotations to add to pods
podAnnotations: { }

# -- Extra init containers to inject into the main Pod spec
extraInitContainers: [ ]
# -- Extra sidecar containers to inject into the main Pod spec
extraContainers: [ ]
# -- Extra volumes to add to the main Pod spec
extraVolumes: [ ]
# -- Extra volume mounts to add to the main container
extraVolumeMounts: [ ]
# -- Extra environment variables to inject into the main container
extraEnvVars: [ ]
# -- Extra envFrom entries to inject into the main container
extraEnvFrom: [ ]
# -- Name of a ConfigMap with extra environment variables to inject into the main container
extraEnvVarsCM: ""
# -- Name of a Secret with extra environment variables to inject into the main container
extraEnvVarsSecret: ""

image:
  # -- Main container image registry
  registry: docker.io
  # -- Main container image repository
  repository: conductoross/conductor-standalone
  # -- Main container image tag
  tag: 3.15.0
  # -- Main container image pull policy
  pullPolicy: IfNotPresent

serviceAccount:
  # -- Create a dedicated ServiceAccount
  create: true
  # -- Name for the ServiceAccount (autogenerated when empty)
  name: ""
  # -- Additional annotations to add to ServiceAccount
  annotations: { }

# -- Number of old ReplicaSets to retain
revisionHistoryLimit: 10

# -- Deployment update strategy (type only is used)
updateStrategy:
  type: RollingUpdate

# -- Pod priority class name
priorityClassName: ""

# -- Pod termination grace period
terminationGracePeriodSeconds: 60

# -- Pod security context configuration
podSecurityContext:
  # -- Enable pod security context
  enabled: true
  runAsUser: 1001
  runAsGroup: 1001
  runAsNonRoot: true
  fsGroup: 1001

# -- Container security context configuration
containerSecurityContext:
  # -- Enable container security context
  enabled: true
  runAsUser: 1001
  runAsGroup: 1001
  runAsNonRoot: true
  privileged: false
  readOnlyRootFilesystem: false
  allowPrivilegeEscalation: false
  capabilities:
    drop: [ "ALL" ]
  seccompProfile:
    type: "RuntimeDefault"

# -- Main container requests/limits
#  memory calculation: onHeapMb (JVM Heap max size)
#   + maxMetaspaceSizeMb (JVM Metaspace max size)
#   + reservedCodeCacheSizeMb (JVM ReservedCodeCache size)
#   + maxDirectMemorySizeMb (JVM DirectMemory max size)
#   + ~512MB (other overheads; e.g., thread stacks, GC, symbols, etc.)
resources:
  requests:
    cpu: 300m
    memory: 2Gi
  limits:
    cpu: "2"
    memory: 3Gi

# -- Liveness probe configuration
livenessProbe:
  # -- Enable liveness probe
  enabled: true
  httpGet:
    path: /health
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 30
  timeoutSeconds: 10
  failureThreshold: 3
  successThreshold: 1

# -- Readiness probe configuration
readinessProbe:
  # -- Enable readiness probe
  enabled: true
  httpGet:
    path: /health
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 10
  failureThreshold: 3
  successThreshold: 1

# -- Startup probe configuration
startupProbe:
  # -- Enable startup probe
  enabled: true
  httpGet:
    path: /health
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 1
  failureThreshold: 15
  successThreshold: 1

# -- Lifecycle hooks configuration
lifecycleHooks: { }

container:
  # -- Container ports used by the Pod spec and as Service targetPort values
  ports:
    rest: 8080
    ui: 5000

service:
  # -- Service type (ClusterIP, NodePort, LoadBalancer)
  type: ClusterIP
  # -- Service ports used by the Service spec. targetPort fields reference container.ports.*
  ports:
    # -- Service port for REST API
    rest: 8080
    # -- Service port for UI
    ui: 5000
  nodePorts:
    # -- NodePort value for REST API when service.type is NodePort
    rest: ""
    # -- NodePort value for UI when service.type is NodePort
    ui: ""

# -- Node selector
nodeSelector: { }
# -- Node tolerations
tolerations: [ ]
# -- Node affinity
affinity: { }
# -- Topology spread constraints
topologySpreadConstraints: [ ]

networkPolicy:
  # -- Create a NetworkPolicy
  create: false
  # -- Name for the NetworkPolicy (defaults to fullname when empty)
  name: ""
  # -- NetworkPolicy ingress rules
  ingress: [ ]
  # -- NetworkPolicy egress rules
  egress: [ ]

podDisruptionBudget:
  # -- Create a PodDisruptionBudget for high availability
  create: false
  # -- Minimum number of pods that must be available during disruptions (mutually exclusive with maxUnavailable)
  minAvailable: 1
  # -- Maximum number of pods that can be unavailable during disruptions (mutually exclusive with minAvailable)
  maxUnavailable: ""
  # Alternatively, use maxUnavailable (mutually exclusive with minAvailable)
  # maxUnavailable: "50%"

autoscaling:
  # -- Create a HorizontalPodAutoscaler
  create: false
  # -- Minimum number of replicas
  minReplicas: 1
  # -- Maximum number of replicas
  maxReplicas: 10
  # -- Target CPU utilization percentage
  targetCPUUtilizationPercentage: 80
  # -- Target memory utilization percentage
  targetMemoryUtilizationPercentage: 80

ingress:
  # -- Create an Ingress for external HTTP access
  create: false
  # -- IngressClass that will be used to implement the Ingress
  className: ""
  # -- Additional annotations for the Ingress
  annotations: { }
  # -- List of Ingress hosts with paths for API and UI
  hosts:
    - host: conductor-api.local
      paths:
        - path: /
          pathType: Prefix
          port: 8080
    - host: conductor-ui.local
      paths:
        - path: /
          pathType: Prefix
          port: 5000
  # -- TLS configuration for Ingress
  tls: [ ]

# App specific
# -- Number of pods
replicaCount: 1

memory:
  # -- On-heap memory limit in MB. If set, -Xms and -Xmx will be value. If not set, defaults to 2048
  onHeapMb: ""
  # -- JVM Metaspace max size in MB. If not set, defaults to 256
  maxMetaspaceSizeMb: ""
  # -- JVM ReservedCodeCache size in MB. If not set, defaults to 240
  reservedCodeCacheSizeMb: ""
  # -- JVM G1 Heap region size in MB. If not set, defaults to 1
  g1HeapRegionSizeMb: ""
  # -- JVM DirectMemory max size in MB. If not set, defaults to 256
  maxDirectMemorySizeMb: ""

# -- App configuration
app:
  asyncUpdateShortRunningWorkflowDuration: "10m"
  enableRemoveRedisKey: false
  lockTimeToTry: 500
  maxTaskInputPayloadSizeThreshold: "4GB"
  maxTaskOutputPayloadSizeThreshold: "4GB"
  maxWorkflowInputPayloadSizeThreshold: "4GB"
  maxWorkflowOutputPayloadSizeThreshold: "4GB"
  maxWorkflowVariablesPayloadSizeThreshold: "100MB"
  systemTaskMaxPollCount: 20
  systemTaskWorkerThreadCount: 20
  taskInputPayloadSizeThreshold: "1MB"
  taskOutputPayloadSizeThreshold: "1MB"
  ttlRedisKeyExpire: ""
  workflowExecutionLockEnabled: true
  workflowInputPayloadSizeThreshold: "1MB"
  workflowOutputPayloadSizeThreshold: "1MB"
  workflowRepairServiceEnabled: false

# -- DB configuration. Allowed values: redis_standalone, mysql, postgres, memory
db:
  type: redis_standalone

# -- Queue configuration. Allowed values: redis_standalone, postgres
queue:
  type: redis_standalone

# -- Workflow execution lock configuration. Allowed values: redis, noop
workflowExecutionLock:
  type: redis

# -- Indexing configuration. Allowed values: elasticsearch, opensearch, postgres, standalone
indexing:
  enabled: true
  type: elasticsearch

# -- External payload storage configuration. Allowed values: postgres, null
externalPayloadStorage:
  type: null

# -- Redis configuration
redis:
  host: ""
  port: 6379
  ssl: false
  password: ""
  taskDefCacheRefreshInterval: 1
  workflowNamespacePrefix: "conductor"
  queueNamespacePrefix: "conductor_queues"

# -- Elasticsearch configuration
elasticsearch:
  enabled: false
  url: ""
  username: ""
  password: ""
  indexName: ""
  indexPrefix: ""
  indexReplicasCount: 0
  version: 7
  clusterHealthColor: yellow
  restClientConnectionTimeout: 5000
  restClientReadTimeout: 30000

# -- MySQL configuration
mysql:
  host: ""
  port: 3306
  username: ""
  password: ""
  database: ""

# -- PostgreSQL configuration
postgres:
  host: ""
  port: 5432
  username: ""
  password: ""
  database: ""

# -- OpenSearch configuration
opensearch:
  url: ""
  username: ""
  password: ""
  indexName: ""
  indexPrefix: ""
  indexReplicasCount: 0
  version: 0
  clusterHealthColor: green
  restClientConnectionTimeout: 5000
  restClientReadTimeout: 30000

# -- Metrics configuration
metrics:
  loggerEnabled: false
  loggerReportPeriodSeconds: 1
  prometheusEnabled: false

management:
  # -- Enable Redis health check
  healthRedisEnabled: true
  # -- Comma-separated actuator endpoints to expose
  endpointsWebExposureInclude: "health,info,metrics,prometheus"

spring:
  # -- Spring profiles passed via SPRING_PROFILES_ACTIVE
  profilesActive: "logrotate"

# -- Environment variables
env:
  EXTRA_JVM_OPTS: ""
